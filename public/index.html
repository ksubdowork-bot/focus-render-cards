<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>BX AI Focus Group</title>
  <style>
    :root{
      --brand:#5b6cff;
      --brand-ghost:#eef0ff;
      --ink:#121418;
      --muted:#6b7280;
      --card:#ffffff;
      --bg:#f7f8fb;
      --ok:#10b981;
      --danger:#ef4444;
      --ans-bg:#1f2430;
      --ans-fg:#ffffff;
      --radius:14px;
      --radius-sm:10px;
      --shadow:0 10px 30px rgba(41,53,108,.10);
      --shadow-sm:0 6px 18px rgba(41,53,108,.08);
      --chip:#f2f4f7;
    }
/* --- Consent Gate (splash) --- */
.consent-backdrop{
  position:fixed; inset:0; background:rgba(17,24,39,.6);
  display:flex; align-items:center; justify-content:center; z-index:9999;
}
.consent-modal{
  width:min(680px, 92vw);
  background:#fff; border-radius:16px; box-shadow:0 20px 60px rgba(0,0,0,.25);
  padding:22px;
}
.consent-title{font-size:18px; font-weight:800; margin:0 0 8px}
.consent-desc{font-size:14px; color:#4b5563; white-space:pre-wrap; line-height:1.6}
.consent-actions{display:flex; gap:8px; justify-content:flex-end; margin-top:18px}
/* 앱 잠금 */
.app-disabled{ filter:blur(1px); pointer-events:none; user-select:none; }

/* (선택) 모달 안의 기본 버튼 컬러가 그라데이션에 덮이지 않도록 */
.consent-modal .btn.primary{ background:var(--brand); color:#fff }
    
    *{box-sizing:border-box}

    
    body{
      margin:0; background:var(--bg); color:var(--ink);
      font:14px/1.5 system-ui,-apple-system,Segoe UI,Roboto,Pretendard,Apple SD Gothic Neo,Malgun Gothic,sans-serif;
    }
    .wrap{max-width:980px; margin:32px auto; padding:0 16px}
    h1{font-size:20px; margin:0 0 16px; display:flex; gap:10px; align-items:center}
    .badge{font-size:12px; padding:4px 8px; border-radius:999px; background:#e9eefb; color:#4252d9}
    .mode-toggle{margin-left:auto; display:flex; gap:8px; align-items:center}
    .pill{
      display:inline-flex; align-items:center; gap:8px;
      background:#fff; padding:4px; border-radius:999px; box-shadow:var(--shadow-sm)
    }
    .pill input{display:none}
    .pill label{
      padding:6px 12px; border-radius:999px; cursor:pointer; color:var(--muted)
    }
    .pill input:checked + label{ background:var(--brand); color:#fff }

    .section{
      background:var(--card); border-radius:var(--radius);
      padding:18px; box-shadow:var(--shadow); margin:14px 0;
    }
    .sec-title{font-weight:700; margin:0 0 12px; font-size:16px}
    .row{display:grid; grid-template-columns:1fr 1fr; gap:10px}
    .full{grid-column:1 / -1}
    input,textarea,select{
      width:100%; padding:12px 14px; border:1px solid #e5e7eb; border-radius:10px;
      background:#fff; outline:none; transition:.15s; font:inherit;
    }
    input:focus,textarea:focus,select:focus{border-color:var(--brand); box-shadow:0 0 0 3px var(--brand-ghost)}
    textarea{min-height:96px; resize:vertical}
    .hint{font-size:12px; color:var(--muted); margin-top:8px}

    .btns{display:flex; gap:8px; flex-wrap:wrap; margin-top:10px}
    .btn{
      border:none; padding:10px 14px; border-radius:10px; cursor:pointer; font-weight:600;
      box-shadow:var(--shadow-sm); background:#f3f4f6; color:#111827;
    }
    .btn.primary{ background:var(--brand); color:#fff }
    .btn.ghost{ background:#fff }
    .btn.success{ background:var(--ok); color:#fff }
    .btn.danger{ background:#fff0f0; color:#b91c1c }

    .cards{display:grid; grid-template-columns:repeat(auto-fill,minmax(240px,1fr)); gap:10px; margin-top:10px}
    .card{
      background:#fff; border:1px solid #eef0f4; border-radius:12px; padding:12px; display:flex; gap:10px; align-items:flex-start;
      box-shadow:var(--shadow-sm); position:relative;
    }
    .card .name{font-weight:700}
    .card .meta{font-size:12px; color:var(--muted); margin-top:2px}
    .chip{display:inline-block; padding:4px 8px; border-radius:999px; background:var(--chip); font-size:12px; color:#555}

    .card .kebab{ position:absolute; top:8px; right:8px; display:flex; gap:6px }
    .tag { font-size:11px; padding:3px 8px; border-radius:999px; background:#eef2ff; color:#4f46e5 }

    .answer{
      background:var(--ans-bg); color:var(--ans-fg);
      border-radius:12px; padding:14px; white-space:pre-wrap; box-shadow:var(--shadow-sm)
    }
    .list-inline{display:flex; gap:8px; flex-wrap:wrap}
    .persona-pill{
      padding:10px 12px; border:1px dashed #e5e7eb; border-radius:12px; min-height:64px; background:#fff
    }

    @media (max-width:720px){
      .row{grid-template-columns:1fr}
      .mode-toggle{width:100%; justify-content:flex-end}
    }
  </style>
</head>
<body>
    <div id="appRoot" class="app-disabled">
  <div class="wrap">
    <h1>
      AI 익스피리언스 포커스 그룹
      <span id="modeBadge" class="badge">DEMO</span>
      <div class="mode-toggle">
        <div class="pill">
          <input type="radio" name="mode" id="modeDemo" value="demo" checked>
          <label for="modeDemo">Demo</label>
          <input type="radio" name="mode" id="modeLive" value="live">
          <label for="modeLive">Live</label>
        </div>
      </div>
    </h1>

    <!-- 1) 페르소나 입력/저장 -->
    <section class="section" id="secSave">
      <div class="sec-title">1) 페르소나 입력/저장 (최대 5명)</div>
      <div class="row">
        <div>
          <label>이름</label>
          <input id="pName" placeholder="예: 도경섭" />
        </div>
        <div>
          <label>모바일 기기</label>
          <input id="pRole" placeholder="예: 갤럭시 Z fold7" />
        </div>
        <div class="full">
          <label>핵심 성향(콤마 구분)</label>
          <input id="pTraits" placeholder="소셜미디어, 영포티아님, 패션, 여행, 육아" />
        </div>
        <div class="full">
          <label>상세 설명</label>
          <textarea id="pBio" placeholder="(자세할수록좋음)모바일 활용, 오프라인 체험에 관한 내용 등"></textarea>
        </div>
      </div>

      <div class="btns">
        <button class="btn primary" id="btnSavePersona">페르소나 저장</button>
        <button class="btn ghost" id="btnLoadSamples">2026트랜드 페르소나 자동입력</button>
        <button class="btn ghost" id="btnRefreshList">목록 새로고침</button>
      </div>

      <div class="hint">* 저장 후 아래 카드에서 “클릭”하면 해당 슬롯/그룹 자동 적용</div>

      <div class="cards" id="personaList"></div>
    </section>
    

    <!-- 2) 솔로 대화 -->
<!-- 2) 솔로 대화 -->
<section class="section" id="secSolo">
  <div class="sec-title">2) 솔로 질문 </div>
  <div class="row">
    <div class="full">
      <label>페르소나</label>
      <select id="soloPersonaSelect"></select>
    </div>
    <div>
      <label>대화 컨텍스트 반영</label>
      <select id="soloLimit">
        <option>10</option><option selected>20</option><option>30</option><option>50</option>
      </select>
    </div>
    <div class="full">
      <label>질문</label>
      <input id="soloQuestion" placeholder="예: 새로운 모바일기기를 구매한다면 어떤기능을 직접 써보고싶을까?" />
    </div>
  </div>
  <div class="btns">
    <button class="btn primary" id="btnAskSolo">질문하기</button>
  </div>
  <!-- ✅ 하나만 남기고 aria 속성 추가 -->
  <div id="soloAnswer" class="answer" style="margin-top:12px; display:none;" aria-live="polite" aria-atomic="true"></div>
</section>
    
 <!-- 3) 그룹 대화 -->
<section class="section" id="secGroup">
  <div class="sec-title">3) 그룹 대화(최대 5명)</div>
  <div class="hint">아래 목록에서 페르소나를 선택하세요. 선택된 페르소나가 발언합니다.</div>

  <div id="groupSelected" class="list-inline" style="margin:8px 0 12px;"></div>

  <div class="row">
    <div class="full">
      <label>토픽 / 과제</label>
      <input id="groupTopic" placeholder="예: 갤럭시 팝업스토어에 간다면 무엇을 제일먼저 보고싶을까?" />
    </div>
    <div>
      <label>라운드 수(기본 2)</label>
      <select id="groupRounds"><option>1</option><option selected>2</option><option>3</option></select>
    </div>
    <div>
      <label>대화 컨텍스트 반영</label>
      <select id="groupLimit"><option>10</option><option selected>20</option><option>30</option><option>50</option></select>
    </div>
  </div>

  <div class="btns">
    <button class="btn success" id="btnStartGroup">그룹 대화 시작</button>
  </div>

  <!-- ✅ 하나만 남기고 aria 속성 추가 -->
  <div id="groupAnswer" class="answer" style="margin-top:12px; display:none;" aria-live="polite" aria-atomic="true"></div>
</section>
    
  </div>
 <footer style="
    bottom:0;
    left:0;
    width:100%;
    text-align:center;
    font-size:12px;
    color:#6b7280;
    background:#f7f8fb;  /* 배경색을 페이지와 통일 */
    padding:8px 0;
    border-top:1px solid #e5e7eb;
  ">
      Experience Design TF · All rights reserved. · Contact: <a href="mailto:k.do@cheil.com">k.do@cheil.com</a>
</footer>
</div> <!-- ✅ appRoot 닫기 -->

<!-- ✅ 동의(Consent) 모달 -->
<div id="consentGate" class="consent-backdrop" role="dialog" aria-modal="true">
  <div class="consent-modal">
    <h2 class="consent-title">안내 및 동의</h2>
<p class="consent-desc">
BX AI Focus Group App 은 페르소나를 입력하거나, 미리 준비된 소비자 페르소나를 불러와 AI 모더레이터와 함께 질문·응답·토론을 진행할 수 있는 도구입니다.
본 앱은 무선 ILP 관련 내용에 특화되어 학습되어 있습니다. 따라서 질문과 인사이트는 무선 ILP의 경험, 기획, 오프라인 연계 중심으로 진행될 수 있습니다.
  
사용 방법:
1) 프로젝트에 맞는 페르소나를 직접 입력하거나, 2026 소비자 인사이트 페르소나(리서치기관 정보 활용)를 선택합니다.
2) 솔로 질문 또는 그룹 대화를 통해 원하는 주제로 AI 토론을 진행합니다. 주제/ 질문이 정확하고 구체적일 수록 좋은 인사이트를 얻을 수 있습니다.
3) 대화 결과에서 프로젝트에 활용할 수 있는 인사이트를 얻습니다.

본 앱의 ILP외 이벤트/전시 관련 AI 질문·응답·토론 사용 문의는 Experience Design TF 로 연락 바랍니다.  
문의: <a href="mailto:k.do@cheil.com">k.do@cheil.com</a>

긍정적인 마인드와 AI 활용에 동의하시면 서비스를 계속 이용할 수 있습니다.
</p>
    <div class="consent-actions">
      <button id="consentReject" class="btn">취소</button>
      <button id="consentAccept" class="btn primary">동의</button>
    </div>
  </div>
</div>
  <script>
    // --- 로딩 말줄임표 애니메이션 ---
const _loadingTimers = new WeakMap();

/** el 안에 baseText + ... 를 0~3개 반복 표시 */
function startEllipsis(el, baseText = "") {
  stopEllipsis(el);
  el.setAttribute("aria-busy", "true");   // ✅ 로딩 상태
  let i = 0;
  el.textContent = baseText;
  const id = setInterval(() => {
    i = (i + 1) % 4;
    el.textContent = baseText + ".".repeat(i);
  }, 400);
  _loadingTimers.set(el, id);
}

function stopEllipsis(el) {
  const id = _loadingTimers.get(el);
  if (id) {
    clearInterval(id);
    _loadingTimers.delete(el);
  }
  el.removeAttribute("aria-busy");        // ✅ 로딩 종료
}
    // -------- 상태 & 유틸
    const $ = sel => document.querySelector(sel);
    const $$ = sel => Array.from(document.querySelectorAll(sel));
    const modeBadge = $("#modeBadge");
    const modeDemo = $("#modeDemo");
    const modeLive = $("#modeLive");

    const LSK = "personas.v1"; // localStorage key

    function toast(msg){ alert(msg); }

    function loadPersonas(){
      try{
        const arr = JSON.parse(localStorage.getItem(LSK) || "[]");
        return Array.isArray(arr) ? arr : [];
      }catch(_){return [];}
    }
    function savePersonas(arr){
      localStorage.setItem(LSK, JSON.stringify(arr.slice(0,5)));
    }
    function addPersona(p){
      const arr = loadPersonas();
      if(arr.length >= 5){ toast("최대 5명까지 저장할 수 있어요."); return false; }
      arr.unshift(p);
      savePersonas(arr);
      return true;
    }
    function updatePersona(idx, p){
      const arr = loadPersonas();
      if(arr[idx]){ arr[idx] = p; savePersonas(arr); }
    }
    function deletePersona(idx){
      const arr = loadPersonas();
      arr.splice(idx,1);
      savePersonas(arr);
    }

    function renderPersonaList(){
      const list = loadPersonas();
      const box = $("#personaList");
      box.innerHTML = "";
      list.forEach((p, idx) => {
        const el = document.createElement("div");
        el.className = "card";
        el.innerHTML = 
          <div style="flex:1">
            <div class="name">${esc(p.name || "이름없음")}</div>
            <div class="meta">${esc(p.role || "")}</div>
            <div class="meta" style="margin-top:6px">${esc(p.traits || "")}</div>
          </div>
          <div class="kebab">
            <button class="btn ghost" data-edit>편집</button>
            <button class="btn danger" data-del>삭제</button>
          </div>
        ;
        // 클릭하면 솔로/그룹 선택 적용
        el.addEventListener("click", (e)=>{
          if(e.target.matches("[data-del]")) return; // 삭제버튼은 별도 처리
          if(e.target.matches("[data-edit]")) return; // 편집버튼은 별도 처리
          applyPersonaToSelectors(p);
        });
        // 삭제
        el.querySelector("[data-del]").addEventListener("click",(e)=>{
          e.stopPropagation();
          if(confirm("이 페르소나를 삭제할까요?")){
            deletePersona(idx);
            renderPersonaList();
            refreshSelectors();
          }
        });
        // 편집
        el.querySelector("[data-edit]").addEventListener("click",(e)=>{
          e.stopPropagation();
          const np = promptEditPersona(p);
          if(np){
            updatePersona(idx, np);
            renderPersonaList();
            refreshSelectors();
          }
        });
        box.appendChild(el);
      });
      refreshSelectors();
      renderGroupPickArea();
    }

    function promptEditPersona(old){
      const name = prompt("이름", old.name || "");
      if(name===null) return null;
      const role = prompt("모바일 기기", old.role || "");
      if(role===null) return null;
      const traits = prompt("핵심 성향(콤마 구분)", old.traits || "");
      if(traits===null) return null;
      const bio = prompt("상세 설명", old.bio || "");
      if(bio===null) return null;
      return {name:name.trim(), role:role.trim(), traits:traits.trim(), bio:bio.trim()};
    }

    function esc(s){ return (s||"").replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m])); }

    // 솔로/그룹 선택박스 채우기
    function refreshSelectors(){
      const list = loadPersonas();
      const sel = $("#soloPersonaSelect");
      const v = sel.value;
      sel.innerHTML = list.map(p => <option value="${esc(p.name)}">${esc(p.name)}</option>).join("");
      if(list.length===0) sel.innerHTML = <option value="" disabled selected>저장된 페르소나 없음</option>;
      else if(v && list.some(p=>p.name===v)) sel.value = v;
      renderGroupPickArea();
    }

    function applyPersonaToSelectors(p){
      // 솔로 선택 박스
      const sel = $("#soloPersonaSelect");
      sel.value = p.name;
      // 그룹 선택칩 토글
      toggleGroupPerson(p.name);
    }

    // 그룹 선택 UI
    function renderGroupPickArea(){
      const box = $("#groupSelected");
      const list = loadPersonas();
      box.innerHTML = "";
      list.forEach(p=>{
        const chip = document.createElement("div");
        chip.className = "persona-pill";
        chip.dataset.name = p.name;
        chip.innerHTML = <div style="font-weight:700">${esc(p.name)}</div><div class="meta">${esc(p.role)}</div><div class="meta">${esc(p.traits)}</div>;
        chip.addEventListener("click", ()=> toggleGroupPerson(p.name));
        box.appendChild(chip);
      });
      updateGroupSelectedStyles();
    }
    function getGroupSelected(){
      const set = JSON.parse(sessionStorage.getItem("group.selected")||"[]");
      return Array.isArray(set)? set : [];
    }
    function setGroupSelected(arr){
      sessionStorage.setItem("group.selected", JSON.stringify(arr.slice(0,5)));
      updateGroupSelectedStyles();
    }
    function toggleGroupPerson(name){
      let arr = getGroupSelected();
      if(arr.includes(name)) arr = arr.filter(x=>x!==name);
      else{
        if(arr.length>=5){ toast("그룹은 최대 5명까지 선택 가능합니다."); return; }
        arr.push(name);
      }
      setGroupSelected(arr);
    }
    function updateGroupSelectedStyles(){
      const selected = new Set(getGroupSelected());
      $$("#groupSelected .persona-pill").forEach(el=>{
        if(selected.has(el.dataset.name)){
          el.style.borderColor = "var(--brand)";
          el.style.background = "#fafaff";
        }else{
          el.style.borderColor = "#e5e7eb";
          el.style.background = "#fff";
        }
      });
    }

    // ---------- (수정) 샘플: 서버 우선, 실패 시 하드코딩 4명으로 폴백
    async function loadSamplePersonas(){
      const fallback = [
        {name:"The Pioneers", role:"아이폰 16 pro", traits:"아이폰,Doer, Spontaneous, Risk-takers, Switching Modes", bio:"핵심 가치 : 새 아이디어·스마트 디자인에 강하게 이끌림, 디지털-피지컬의 유기적 연결을 탐구하되 일·삶 경계는 명확히 유지(워라벨) 새 기술이 생기면 늘 먼저 써보고, 내 방식에 얼마나 잘 녹아드는지가 기준. 유니버설 디자인·지속가능 제품에 실천적 관심(재사용·수선·모듈러 선호)  . 창업가적·충동적 시도, 모드 전환이 빠른 리스크테이커, Lifestyle : 뉴욕의 빠른 리듬 속에서  늘 “다음 아이디어를 내지 않으면 뒤처진다”는 긴장감을 안고 산다. 아침 7시, 세티스파이 브랜드 복장(서스테이너블 소재 및 러닝 전문 브랜딩) 으로 러닝 후 출근. 오전에는 팝업 전시 협업 미팅—로 실물 전시를  Vision Pro 앱에서 ‘프리뷰’해보고,  오후엔 프로토타입을 3D 프린트한 뒤 핸즈 온 테스트. 퇴근이 명확하지 않은 그는 저녁 8시 스스로 알림을 끊고 하루에 꼭 ‘디지털 오프라인 타임’을 지킨다. 저녁엔 ‘포커스 모드’를 켜 소셜 알림을 차단해 개인 시간을 지킨다(연결 추구와 경계 설정의 공존). 매달 마지막 주 금요일엔 중고 플랫폼에서 팀 장비를 순환 판매/구매해 폐기물 최소화. 변화가 끊이지 않는 뉴욕에 새로운 장소가 생길 때마다 어김없이 살펴보는 것도 루틴이다. 자기만의 리듬, 자기만의 기준이 분명한 사람이다, Device Habit : 	iPhone–iPad–Mac을 무선 연동해 스케치→프로토→AR 시연까지 끊김 없이 진행(디지털-피지컬 브리지를 스튜디오 밖 IRL로 확장). 사용 앱·단축어·포커스 모드가 생활 리듬에 맞춰 자동 전환(‘Switching Modes’의 일상화), 스케치 앱, 자동화 단축어, 노이즈 캔슬, 디바이스 간 전환 같은몰입 기능은 다 켜놓고 쓴다. AI 기능도, 그냥 말 걸어보는 게 아니라내가 쓰는 방식대로 반응하는지 본다.러닝시 심박/거리 체크, iOS에 최적화된 기본 업무 파이프라인, 자기만의 몰입 흐름, 장비 구성, 시간 감각을 해치지 않게 루틴화된 셋팅. 클라우드·에어드롭 기반 공유와 단축어 자동화가 핵심 생산성 자산. 갤럭시 전환 시 협업 속도·프로토타이핑이 느려져진다고 판단 “팀이 iOS 기반으로 맞춘 워크플로우를 바꾸면, 한 템포 늦는 순간 바로 경쟁에서 밀린다” 내가 원하는 몰입, 효율, 루틴을 깨지 않고 써왔기 때문에” iPhone을 고수"},
        {name:"The Reductionists", role:"아이폰 16 pro", traits:"Busy, Values-driven, Community-focused, Seeking connection", bio:"핵심 가치 : 뉴욕은 개인주의와 속도전의 도시지만, 지민은 바로 그 안에서 “사람과 사람의 따뜻한 연결”을 지켜내려 한다. 그녀의 요가 수업은 경쟁보다 호흡과 균형을 되찾는 공간으로, 도시의 소란과 불안을 잠시 잊게 한다. 회원들에게 필요한 건 화려한 서비스가 아니라 진정성 있는 돌봄이라고 믿는다, Lifestyle : 아침에는 회원들과 함께 하는 라이브 온라인 수업을 송출하고, 오후에는 오프라인 스튜디오에서 강의를 진행한다. 수업 중에는 회원들의 자세를 직접 교정하면서, 동시에 카메라로 촬영해 맞춤 피드백 영상을 제공한다. 수업 후에는 회원들과 Hudson 강변을 함께 걷고, 야외 클라스 운영, 운영과 동시에 촬영 및 소시얼 라이브 송출, 저녁에는 SNS용 숏폼 영상을 편집해 업로드하며 새로운 회원을 끌어들인다. 집에서는 반려묘(러시안블루)와 함꼐 지내며, 계정에도 고양이가 자연스럽게 등장하는 일상 컷을 공유, 전문성과 따듯한 라이프스타일 이미지를 동시에 강화, Device Habit : 촬영을 통한 회원들의 자세를 분석·교정 영상 제공, AI 편집으로 촬영 즉시 SNS용 콘텐츠 제작, AI 편집, 기기 내 편집등 도시적 속도에 대응, 어두운 스튜디오에서도 촬영 횟수 많음. 집에서는 고양이의 요가자세같은 순간을 포착하여 촬영, Lock-in : 전문가 모드 고화질 촬영으로 빠른 콘텐츠 경쟁 속에서도 돋보이는 퀄리티 보장, 수업분위기와 추구미에 따른 다양 한분위기에서 의 촬영 필요  “갤럭시의 AI 카메라와 고화질 촬영 없이는 내 온라인 수업과 홍보 콘텐츠의 전문성을 유지할 수 없다.”"},
        {name:"The Time Keepers", role:"아이폰 17", traits:"Discerning, Gourmet, Aesthetic, Seeking enrichment", bio:"핵심 가치 :  시간을 최우선 자원으로 보고 업무 효율·디스트랙션 최소화를 중시. 의미 있는 경험·관계에 시간을 재투자. 시간 절약형 서비스와 렌탈·부분 소유 모델 선호(소유 대신 활용 효율), 미감·미식 감수성과 ‘삶의 품위’도 추구, Lifestyle : 월요일 싱가포르, 수요일 도쿄, 금요일 서울. 아침 공항 라운지에서 문서를 검토하고, 비행 중 콜 2건을 처리. 호텔 체크인 즉시 ‘업무 알림만 허용’ 프로필로 전환해 산만함을 줄인다. 출퇴근은 모빌리티 구독, 출장 중 촬영은 장비 렌탈(부분 소유)로 해결—관리 비용 대신 ‘즉시 가용성’을 산다. 출장이 많아 공유오피스·렌탈 스튜디오를 적극 활용해 ‘소유하지 않고 활용하는 삶’을 실천한다. 저녁엔 가족과 식사 약속을 고정 슬롯으로 지키고, 도시마다 미식을 즐긴다, Device Habit : S펜으로 클라이언트 피드백을 PDF에 직접 기입, S펜으로 바로 메모·수정, 멀티 테스킹, AI 기반 일정 정리와 고화질 카메라로 출장 중 문서·계약서 즉시 스캔/공유, 워치로 다양한 시차에 따른 수면질과 건강 관리, Lock-in : 워크프로세스 연결 및 주변 기기활용, 수면 스코어, 수면 코칭으로 건강기능 관리  “동시에 여러 일을 해야 하는 내 환경에서는 갤럭시의 멀티태스킹과 AI 기능이 시간을 돈처럼 지켜준다.”"},
        {name:"The New Nihilists", role:"아이폰 17", traits:"Inward-looking, Unconventional, Quiet-minded, Seeking meaning", bio:"핵심 가치 :  경제·기후·전쟁 등 거시 위기에 압도되어 내면 회귀 경향. 정직·진정성·유머·기쁨을 주는 브랜드에 신뢰를 느끼고, 비주류·미래지향 창작에 강한 흡인. 행복·자율·성공의 기준을 스스로 재정의, 고요 속에서 의미를 찾음, Lifestyle : 낮에는 스튜디오에서 사운드 · 비디오를 겹쳐 작업을 한다. 재료 대부분은 일상에서 채집—도시 소음, 버려진 포스터, 오래된 사진. 밤에는 소규모 커뮤니티의 비공개 상영회에서 작품을 보여주고 직접 대화한다. 인스타그램과 TikTok으로 팬들과 직접 소통하며, 농담과 진솔한 제작기를 공유한다. 줄 이어폰을 쓰고, 그 시절의 미감이 좋아 최근에 구형 아이폰을 구매하여 사용중. 그녀에게 예술은 사회적 혼란 속 자기 정의다. 소소하고 시니컬한 농담으로 긴장을 풀어준다. (AI활용에 대한 고민), Device Habit :  iPhone으로 촬영 → 모바일 편집 → 즉시 공유. 간결한 인터페이스와 선호 앱 조합이 창작 몰입을 방해하지 않는다(Quiet-minded한 흐름 유지). 오프라인 전시는 개인디바이스를 활용한 AR로 확장해 관람자에게 ‘개인적 의미 찾기’ 안내를 제공, Lock-in : 미니멀한 인터페이스, 일관된 카메라 퀄리티. 자신의 미감·작업 리듬과 맞춘 iOS 앱·프리셋·오토메이션이 창작의 ‘촉감’을 형성. 전환 시 감각의 타이밍·톤이 달라져 결과물이 변질된다고 느낀다. “iOS는 내 창작 리듬과 감각을 그대로 살려준다. 갤럭시로 바꾸면 작품의 질감과 리듬이 깨질 것 같다.”"}
      ];
      try{
        const r = await fetch("/personas-list");
        if(!r.ok) throw new Error("server list failed");
        const data = await r.json(); // {ok, items}
        const items = (data && data.ok && Array.isArray(data.items) && data.items.length) ? data.items : fallback;
        const cur = loadPersonas();
        // 이름 기준 중복 제거
        const merged = [...items, ...cur].reduce((acc,p)=>{
          if(!acc.find(x=>x.name===p.name)) acc.push({name:p.name, role:p.role, traits:p.traits, bio:p.bio});
          return acc;
        }, []).slice(0,5);
        savePersonas(merged);
        renderPersonaList();
      }catch(_){
        const cur = loadPersonas();
        const merged = [...fallback, ...cur].reduce((acc,p)=>{
          if(!acc.find(x=>x.name===p.name)) acc.push(p);
          return acc;
        }, []).slice(0,5);
        savePersonas(merged);
        renderPersonaList();
      }
    }

    // -------- 모드 토글
    function currentMode(){ return modeLive.checked ? "live" : "demo"; }
    modeDemo.addEventListener("change", ()=> modeChanged());
    modeLive.addEventListener("change", ()=> modeChanged());
    function modeChanged(){
      const m = currentMode();
      modeBadge.textContent = m==="live" ? "LIVE" : "DEMO";
      modeBadge.style.background = m==="live" ? "#e6fff3" : "#e9eefb";
      modeBadge.style.color = m==="live" ? "#15803d" : "#4252d9";
    }

// -------- 솔로 대화
$("#btnAskSolo").addEventListener("click", async ()=>{
  const name = $("#soloPersonaSelect").value;
  const q = $("#soloQuestion").value.trim();
  const limit = parseInt($("#soloLimit").value,10) || 20;
  if(!name) return toast("페르소나를 선택하세요.");
  if(!q) return toast("질문을 적어주세요.");
  const p = loadPersonas().find(x=>x.name===name);
  if(!p) return toast("선택한 페르소나를 찾을 수 없습니다.");

  const out = $("#soloAnswer");
  out.style.display = "block";

  if(currentMode()==="demo"){
    out.textContent = [DEMO] ${p.name}의 시점으로 답변합니다.\n\nQ. ${q}\n\n- (데모 응답) 실제 모드는 서버 API 연결 후 작동합니다.;
    return;
  }

  try{
    // ✅ 로딩 애니메이션 시작
    startEllipsis(out, "[LIVE] AI 응답 작성중");

    const res = await fetch("/chat/solo",{
      method:"POST",
      headers:{ "Content-Type":"application/json" },
      body: JSON.stringify({ persona:p, question:q, historyLimit:limit })
    });
    if(!res.ok){
      const t = await res.text();
      throw new Error(HTTP ${res.status} - ${t});
    }
    const data = await res.json();
    out.textContent = (data.answer||"").trim() || "(빈 응답)";
  }catch(err){
    out.textContent = 오류: ${err.message};
  } finally {
    // ✅ 로딩 애니메이션 정지
    stopEllipsis(out);
  }
});

    // -------- 그룹 대화
$("#btnStartGroup").addEventListener("click", async ()=>{
  const names = getGroupSelected();
  const list = loadPersonas().filter(p=>names.includes(p.name));
  if(list.length===0) return toast("그룹에 참여시킬 페르소나를 한 명 이상 선택하세요.");
  const topic = $("#groupTopic").value.trim() || "자유 토론";
  const rounds = parseInt($("#groupRounds").value,10) || 2;
  const limit = parseInt($("#groupLimit").value,10) || 20;

  const out = $("#groupAnswer");
  out.style.display = "block";

  if(currentMode()==="demo"){
    const heads = list.map(p=>p.name).join(", ");
    out.textContent = [DEMO] (${heads}) 라운드 ${rounds}회 대화 요약.\n\n- (데모 응답) 실제 모드는 서버 API 연결 후 작동합니다.;
    return;
  }

  // LIVE 호출
  try{
    // ✅ 로딩 애니메이션 시작
    startEllipsis(out, "[LIVE] 그룹 대화 내용 기록중");

    const res = await fetch("/chat/group",{
      method:"POST",
      headers:{ "Content-Type":"application/json" },
      body: JSON.stringify({ personas:list, topic, rounds, historyLimit:limit })
    });
    if(!res.ok){
      const t = await res.text();
      throw new Error(HTTP ${res.status} - ${t});
    }
    const data = await res.json();

    // (수정) transcript 배열 + summary 지원
    if (Array.isArray(data.transcript)) {
      const lines = data.transcript.map(it => ${it.speaker}: ${it.text}).join("\n");
      const sum = data.summary ? \n\n요약: ${data.summary} : "";
      out.textContent = ${lines}${sum};
    } else {
      out.textContent = (data.transcript || data.summary || "").trim() || "(빈 응답)";
    }
  }catch(err){
    out.textContent = 오류: ${err.message};
  } finally {
    // ✅ 로딩 애니메이션 정지 (성공/실패 모두)
    stopEllipsis(out);
  }
});

    // -------- 저장/편집/삭제
    $("#btnSavePersona").addEventListener("click", ()=>{
      const p = {
        name: $("#pName").value.trim(),
        role: $("#pRole").value.trim(),
        traits: $("#pTraits").value.trim(),
        bio: $("#pBio").value.trim()
      };
      if(!p.name){ toast("이름은 필수입니다."); return; }
      if(addPersona(p)){
        $("#pName").value = $("#pRole").value = $("#pTraits").value = $("#pBio").value = "";
        renderPersonaList();
      }
    });
    $("#btnLoadSamples").addEventListener("click", loadSamplePersonas);
    $("#btnRefreshList").addEventListener("click", renderPersonaList);

  // 초기화
  modeChanged();
  renderPersonaList();

  /* ---------- Consent Gate (항상 표시) ---------- */
  (function consentGate(){
    const gate = document.getElementById('consentGate');
    const app  = document.getElementById('appRoot');

    function openGate(){
      if (gate) gate.style.display = 'flex';
      app?.classList.add('app-disabled');
    }
    function closeGate(){
      if (gate) gate.style.display = 'none';
      app?.classList.remove('app-disabled');
    }

    // 페이지 열릴 때마다 항상 모달 오픈
    openGate();

    document.getElementById('consentAccept')?.addEventListener('click', () => {
      closeGate(); // 동의 시 닫기
    });
    document.getElementById('consentReject')?.addEventListener('click', () => {
      // 거절 시 계속 유지 (원하면 리다이렉트 가능)
      openGate();
    });
  })();
</script>
</body>
</html>
